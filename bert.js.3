.TH bert.js 1 "bert.js" "Synrc Research Center" "BERT.JS"
.SH NAME
bert.js
.SH  ВСТУП
.LP
 Модуль \fIbert.js\fR\& надає JavaScript кодер/декодер для \fIExternal Term Format\fR\&, який використовується в Erlang distribution protocol. Це означає, що ваші JavaScript програми надсилають повідомлення в рідному форматі Erlang. Цей модуль застосовує \fIDataView\fR\&, а також методи \fBgetUint8\fR\&, \fBgetUint16\fR\&, \fBgetUint32\fR\&, які забезпечують найшвидший варіант роботи з бінарними даними в JavaScript. Ця бібліотека використовується в Erlang і Haskell версіях N2O. Розмір \fBbert.js\fR\& — 4654 байта.
.LP
 Зауважте, що це низькорівнева бібліотека, швидка версія BERT кодера/декодера. Якщо ви хочете генерувати JavaScript SDK з іменованими полями, як в файлах заголовків Erlang, підключіть \fIBERT\fR\& — високорівневу бібліотеку-двійника, яка генерує обгортки навколо \fBbert.js\fR\& та забезпечує більш more slick JavaScript досвід. 
.LP
 Erlang структура, яка компілюється в BERT формат:
.nf

 #io{ code = login,
      data = { 'Token', 42 } }
        
.fi

.LP
 Цільова структура \fIbert.js\fR\& — швидкий низькорівневий жорстко закодований парсер з BERT формату.
.LP

.nf

 { t: 104,
   v: [ { t: 100, v: "io" },
        { t: 100, v: "login" },
        { t: 104, v: [ { t: 100, v: "Token" },
                       { t: 97,  v: 42 } ] } ] }
        
.fi

.LP
 Цільова структура згенерованого парсера з \fIBERT\fR\& parse transform:
.LP

.nf

 { tup: 'io',
   code: 'login',
   data: { tup: '$',
           0: 'Token',
           1: 42 } },
        
.fi

.LP
 Підтримується наступна практична підмножина формату BERT:
.SH  70
.LP
 Кодування числа з плаваючою точкою IEEE-754; зберігається у вигляді 8 байтів у big-endian IEEE форматі. Цей вираз використовується в мінорній версії 1 зовнішнього формату. 
.nf

 1    8
 70   IEEE-754 float
        
.fi

.SH  97
.LP
 Кодування байтів. Беззнакове 8-бітне ціле число (integer).
.nf

 1    1
 97   Int
        
.fi

.SH  98
.LP
 Кодування цілих чисел (Integer). 32-бітне ціле число зі знаком, в big-endian форматі.
.nf

 1    4
 98   Int
        
.fi

.SH  99
.LP
 Кодування числа з плаваючою точкою POSIX; зберігається у вигляді строки. Формат використовується в sprintf, для форматування чисел з плаваючою точкою, як "%.20e" (виділяється більше байтів, ніж необхідно). Для розпакування числа з плаваючою точкою використовується sscanf з форматом "%lf". 
.nf

 1    31
 99   Float POSIX string.
        
.fi

.SH  100
.LP
 Кодування атомів. Атом зберігається у вигляді 2-байтового беззнакового цілого числа в big-endian порядку, яким задається довжина, за ним слідують N чисел — 8-бітних Latin-1 знаків (Characters), які є ім'ям атома. Максимально дозволене значення довжини є 255. 
.nf

 1    2    N
 100  N    Characters
        
.fi

.SH  104
.LP
 Кодування кортежу. Поле арності (Arity) — беззнакове 1-байте ціле число N, яке визначає, скільки елементів знаходиться в секції Елементи (Elements). 
.nf

 1    1    N
 104  N    Elements
        
.fi

.SH  105
.LP
 Кодування великого кортежу. Відмінність від 104 — N є беззнаковим 4-байтним цілим числом в big-endian форматі. 
.nf

 1    4    N
 105  N    Elements
        
.fi

.SH  106
.LP
 Nil.
.nf

 1
 106
        
.fi

.SH  107
.LP
 Кодування строки. Оскільки поле N є беззнаковим 2-байтним числом (big-endian), реалізації повинні гарантувати, що списки, довші за 65535 елементів, кодуються за допомогою 108. 
.nf

 1    2    N
 107  N    Characters
        
.fi

.SH  108
.LP
 Кодування списків. N — кількість елементів в секції Символи (Characters). Хвіст (Tail) — остаточний хвіст списку; це 106 для правильного списку, але, у випадку неправильного списку, може бути будь-якого типу (наприклад, [a|b]). 
.nf

 1    4    N
 108  N    Characters  Tail
        
.fi

.SH  109
.LP
 Бінарне кодування. Бінарні строки генеруються за допомогою бітового синтаксичного виразу (bit syntax expression) або erlang:list_to_binary/1, erlang:term_to_binary/1, чи як вхідні дані від бінарних портів (binary ports). Поле довжини N є беззнаковим 4-байтним цілим числом (big-endian). 
.nf

 1    4    N
 109  N    Bytes
        
.fi

.SH  110
.LP
 Кодування малого bignum. Bignum зберігається в унарній формі з байтом знаку, який дорівнює 0, якщо binum позитивний, і 1, якщо негативний. При зберіганні цифр молодший байт зберігаються першим. Для обчислення цілого числа можна використовувати наступну формулу: 
.nf

 1    1    1    n
 110  n    Sign d(0)...d(n-1)
        
.fi

.LP
 B = 256, d 0 *B 0 + d 1 *B 1 + d 2 *B 2 + ... d N-1 *B (n-1)
.SH  111
.LP
 Кодування великого bignum. Відмінність від 110 — поле довжини є беззнаковим 4-байтним цілим числом. 
.nf

 1    4    1    n
 111  n    Sign d(0)...d(n-1)
        
.fi

.SH  115
.LP
 Кодування малого атома. Атом зберігається у вигляді 1-байтового беззнакового цілого числа в big-endian порядку, яким задається довжина, за ним слідують N чисел — 8-бітних Latin-1 знаків (Characters), які є ім'ям атома. Максимально дозволене значення довжини є 16. 
.nf

 1    1    N
 115  N    Characters
        
.fi

.SH  116
.LP
 Кодування мапи (map). Поле N — беззнакове 4-байтне ціле число в big-endian форматі, означає кількість пар "ключ-значення" в map. Пари "ключ-значення" (Ki => Vi) кодуються у секції Пари (Pairs) в наступному порядку: K1, V1, K2, V2,..., Kn, Vn. Дублікати ключів не дозволені в одній і тій же map. Вимагає OTP 17. 
.nf

 1    4    N
 116  N    K1,V1,K2,V2,...
        
.fi

.SH  118
.LP
 Кодування UTF8 атома. Атом зберігається у вигляді 2-байтового беззнакового цілого числа в big-endian порядку, яким задається довжина, за ним слідують N байтів — закодовані в UTF-8 символи (Characters), які є ім'ям атома. 
.nf

 1    2    N
 118  N    Characters
        
.fi

.SH  119
.LP
 Кодування малого UTF8 атома. Атом зберігається у вигляді 1-байтового беззнакового цілого числа, яким задається довжина, за ним слідують N байтів — закодовані в UTF-8 символи (Characters), які є ім'ям атома. Довші атоми, закодовані в UTF-8, можна представити за допомогою 118. 
.nf

 1    1    N
 119  N    Characters
        
.fi

.SH  API enc(json)
.LP
 Кодує внутрішній JSON в двійковий буфер.
.nf

 > enc({t: 119, v: "日本"})

 Uint8Array([131,119,6,230,151,165,230,156,172])
         
.fi
 dec(buffer)
.LP
 Декодує двійковий буфер у внутрішній JSON.
.nf

 > dec((new Uint8Array([131,119,6,230,151,165,230,156,172])).buffer)

 {t: 119, v: "日本"}
         
.fi
 bin(x)
.nf

 > dec(enc(bin('N2O,')).buffer))

 {t: 109, v: "N2O,"}

 [131,109,0,0,0,4,78,50,79,44]
         
.fi

.LP
 Створює JSON для двійкового кодування. atom(x)
.LP
 Створює JSON для кодування Latin-1 атома.
.nf

 > dec(enc(atom('ok')).buffer))

 {t: 100, v: "ok"}

 [131,100,0,2,111,107]
         
.fi
 string(x)
.LP
 Створює JSON для кодування строки.
.nf

 > dec(enc(string('ok')).buffer))

 {t: 107, v: "ok"}

 [131,107,0,2,111,107]
         
.fi
 float(x)
.LP
 Створює JSON для кодування числа з плаваючою точкою IEEE-754.
.nf

 > dec(enc(float('123.13')).buffer)

 {t: 70, v: 123.13}

 [131,70,64,94,200,81,235,133,30,184]
         
.fi
 number(x)
.LP
 Створює JSON для кодування цілих чисел та великих чисел GMP.
.nf

 > dec(enc(number('1')).buffer)

 {t: 97, v: 1}

 [131,97,1]

 > dec(enc(number('100000000')).buffer)
 {t: 98, v: 100000000}

 [131,98,5,245,225,0]

 > dec(enc(number('10000000000000000000000')).buffer)

 {t: 110, v: 1e+22}

 [131,110,10,0,0,0,64,178,186,201,224,25,30,2]
         
.fi
 list(x,...)
.LP
 Створює JSON для кодування списку.
.nf

 > dec(enc(list(atom('1'),number('1'),bin('1'))).buffer)

 {t: 108, v: [{t: 100, v: "1"},
              {t: 97, v: 1},
              {t: 109, v: "1"}]}

 [131,108,0,0,0,3,100,0,1,49,97,1,109,0,0,0,1,49,106]
         
.fi
 tuple(x,...)
.LP
 Створює JSON для кодування кортежу.
.nf

 > dec(enc(tuple(atom('1'),number('1'),bin('1'))).buffer)

 {t: 104, v: [{t: 100, v: "1"},
              {t: 97, v: 1},
              {t: 109, v: "1"}]}

 [131,104,3,100,0,1,49,97,1,109,0,0,0,1,49]
         
.fi
 map(x,...)
.LP
 Створює JSON для кодування мапи.
.nf

 > dec(enc(map(
        {k:bin('rent'),v:float(1.2)},
       {k:atom('ok'),  v:list(number(1),float(1.0),bin('1'))})).buffer)

 {t:116, v:[{k:{t:109,v:"rent"},v:{t:70, v:1.2}},
            {k:{t:100,v:"ok"},  v:{t:108,v:[{t:97, v:1},
                                            {t:70, v:1},
                                            {t:109,v:"1"}]}}]}

 [131,116,0,0,0,2,109,0,0,0,4,114,101,110,
  116,70,63,243,51,51,51,51,51,51,100,0,2,
  111,107,108,0,0,0,3,97,1,70,63,240,0,0,0,
  0,0,0,109,0,0,0,1,49,106]
         
.fi

.SH ALSO
.LP
\fB\fIutf8.js(1)\fR\&\fR\&, \fB\fIieee754.js(1)\fR\&\fR\&, \fB\fIheart.js(1)\fR\&\fR\&, \fB\fInitro.js(1)\fR\&\fR\&, \fB\fImq.js(1)\fR\&\fR\&, \fB\fIn2o.js(1)\fR\&\fR\&